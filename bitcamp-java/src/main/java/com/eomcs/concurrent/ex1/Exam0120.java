// 멀티 스레드 적용 후
package com.eomcs.concurrent.ex1;
// CPU의 시간을 쪼개서 왔다 갔다하면서 동시에 실행하고 싶은 코드가 있다면
// 다음과 같이 Thread를 상속받아 run() 메서드에 그 코드를 두어라.
public class Exam0120 {
  static class MyThread extends Thread {
    @Override
    public void run() {
      // 기존 실행 흐름과 분리하여 따로 실행시킬 코드를
      // 이 메서드에 둔다.
      for (int i = 0; i < 1000; i++) {
        System.out.println("==> " + i);
      }
    }
  }

  public static void main(String[] args) {
    new MyThread().start(); // 오버라이딩한 run()을 호출한다.
    // 코드 실행 라인을 새로 만들어 따로 실행한다.
    // 동시에 실행할 코드를 담고 있는 Thread 객체를 생성한다.
    // 현재 실행과 분리하여 작업을 시작한다.
    // JVM은 이 스레드에 들어있는 코드와 다음에 진행하는 코드를
    // 왔다 갔다하면서 처리할 것이다.
    // 스레드는 비동기로 동작한다.
    // 스레드에 작업을 시킨 후, 그 스레드가 작업이 끝날 때까지 기다리지 않고 즉시 리턴한다.
    // 따라서 스레드 작업과 main()의 코드가 병행(concurrent)으로 실행한다.

    for (int i = 0; i < 1000; i++) {
      System.out.println(">>> " + i);
    }
  }
}

// main() 메서드를 실행하는 기본 실행 흐름에서 새로운 실행 흐름으로 분기하고 싶다면,
// Thread 클래스에 분기해서 실행할 코드를 담으면 된다.
// 그러면 두 개의 실행 흐름이 서로 왔다 갔다하면서 실행된다.

// # 멀티태스킹(multi-tasking)
//  한 개의 CPU가 여러 코드를 동시에(?) 실행하는 것
//  실제는 일정한 시간을 쪼개 이 코드와 저 코드를 왔다 갔다하면서 실행한다.
//  그럼에도 불구하고 외부에서 봤을 때는 명령어가 동시에 실행되는 것처럼 보인다.
//  왜? CPU 속도가 워낙 빠르기 때문이다.

// # CPU의 실행 시간을 쪼개서 배분하는 정책: CPU Scheduling 또는 Process Scheduling
//  CPU의 실행 시간을 쪼개 코드를 실행하는 방법
//  1) Round-Robin 방식(Windows OS)
//    CPU 실행 시간을 일정하게 쪼개서 각 코드에 분배하는 방식
//  2) Priority + Aging 방식(Unix, Linux)
//    우선 순위가 높은 코드에 더 많은 실행 시간을 배정하는 방식
//    우선 순위가 낮은 프로그램인 경우 CPU 시간을 배정받지 못하는 문제점이 있다.
//    그래서 몇 년이 지나도록 실행되지 않는 경우가 나타났다.
//    => CPU 시간을 배정받지 못할 때마다 우선 순위를 높여서 결국 모두 실행되게 만들었다.
//     이런 방식을 "Aging 기법"이라 부른다.

// # 멀티 태스킹을 구현하는 방법
//  1) 멀티 프로세싱
//   프로세스(실행 중인 프로그램)를 복제하여 분기한다.
//   분기된 프로세스를 실행시켜서 작업을 동시에 진행하게 한다.
//   장점: fork()를 호출하면 되니 분기하기가 쉽다. 즉 구현(프로그래밍)하기가 쉽다.
//   단점: 프로세스를 그대로 복제하기 때문에 프로세스가 사용하는 힙 메모리도 그대로 복제된다.
//         메모리 낭비가 심하다. 복제된 프로세스는 독립적이기 때문에 일일히 종료해야 한다.
//  2) 멀티 스레딩
//   특정 코드만 분리하여 실행한다. 따라서 프로세스가 사용하는 메모리를 공유한다.
//   장점: 스레드들은 스택에 저장되고, 프로세스의 힙 메모리를 공유하기 때문에
//         멀티 프로세싱에 비해 메모리 낭비가 적다.
//         모든 스레드는 프로세스에 종속되기 때문에 프로세스를 종료하면 스레드도 자동 종료된다.
//   단점: 프로세스 복제 방식에 비해 코드 구현이 복잡하다.

// ## 컨텍스트 스위칭(context switching)이란?
//  CPU의 실행 시간을 쪼개 이 코드 저 코드를 실행할 때마다
//  실행 위치 및 정보(context)를 저장하고 로딩하는 과정이 필요하다.
//  이 과정을 '컨텍스트 스위칭'이라 부른다.
//  작업을 옮길 때마다 컨텍스트 스위칭할 최소 시간이 필요하다.
//  CPU 사용권을 주기 전에 프로세스나 스레드가 이전에 어디까지 실행했었는지
//  이전 실행 위치 정보를 로딩해야 한다.

// ## 스레드(thread)
// '실'이라는 뜻을 갖고 있다. 하나의 실은 끊기지 않은 하나의 실행 흐름을 의미한다.
// 스레드를 생성한다는 것은 새 실을 만든다는 것으로, 새 실행 흐름을 시작하겠다는 의미다.
// CPU는 프로세스와 마찬가지로 스레드에게 동일한 자격을 부여하여 스케줄링에 참여시킨다.
// 즉 프로세스에 종속된 스레드라고 취급하여
// 한 프로세스에 부여된 실행 시간을 다시 쪼개 스레드에게 나눠 주는 것이 아니다.
// 그냥 단독적인 프로세스와 같이, 동일한 실행 시간을 부여한다.