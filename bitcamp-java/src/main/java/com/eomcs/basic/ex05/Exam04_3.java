// 비트 이동 연산자 : >>, >>>, << 
package com.eomcs.basic.ex05;

public class Exam04_3 {
  public static void main(String[] args) {
    // >>> 비트 이동 연산자 사용법
    // 왼쪽 쪽 빈자리를 원래 숫자와 같은 부호 값으로 채운다.
    //                  양수면 0, 음수면 1을 채운다.
    // 오른쪽 경계를 넘어간 비트 : 자른다.
    int i = 0b01101001; // 105
    // 00000000 00000000 00000000 01101001
    System.out.println(i); 
    System.out.println(i >>> 1); // 00110100|1 => 52
    // x00000000 00000000 00000000 0110100|1
    // 00000000 00000000 00000000 00110100
    System.out.println(i >>> 2); // 00011010|0 => 26
    // xx00000000 00000000 00000000 011010|01
    // 00000000 00000000 00000000 00011010
    System.out.println(i >>> 3); // 00001101|0 => 13
    // xxx00000000 00000000 00000000 01101|001
    // 00000000 00000000 00000000 00001101
    System.out.println(i >>> 4); // 00000110|1 => 6
    // xxxx00000000 00000000 00000000 0110|1001
    // 00000000 00000000 00000000 00000110

    // 음수를 이동
    // => 0으로 채운다.
    // => 2로 나눈 후에 소수점이 있으면 
    //    그 수보다 더 작은 정수값이 되는 결과가 나온다.
    i = 0b11111111_11111111_11111111_10101001; // -87 양수 01010111
    System.out.println(i); 

    System.out.println(i >>> 1); 
    // x1111111111111111111111111010100|1
    // 01111111111111111111111111010100 => 2147483604

    System.out.println(i >>> 2); 
    // xx111111111111111111111111101010|01
    // 00111111111111111111111111101010 => 1073741802

    System.out.println(i >>> 3); 
    // xxx11111111111111111111111110101|001
    // 00011111111111111111111111110101 => 536870901

    System.out.println(i >>> 4);
    // xxxx1111111111111111111111111010|1001
    // 00001111111111111111111111111010 => 268435450
  }
}

//오른쪽 이동
//- 1비트 이동은 나누기 2 한 것과 같은 효과를 준다.
//- 소수점이 있는 경우 그 수보다 작은 바로 밑 정수 값이 된다.
// 실무에서는 나눗셈 연산이 비용(시간과 CPU 사용량)이 많이 들기 때문에
// 소수점 이하까지 정확하게 계산할 게 아니라면
// 오른쪽 비트 이동 연산자를 사용하여 주로 처리한다.