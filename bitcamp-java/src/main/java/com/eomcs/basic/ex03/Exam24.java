package com.eomcs.basic.ex03;

// 정수 리터럴(literal) 정수를 메모리에 저장하는 방법
//
public class Exam24 {
  public static void main(String[] args) {

    System.out.println(23);
    // 23
    // => 0000 0000 0000 0000 0000 0000 0001 0111 (4바이트 표현)

    System.out.println(-23);
    // -23
    // 1) Sign-magnitude : 맨 앞 비트로 음수를 표시 (1이면 음수 0이면 양수) 인간이 이해하기 편함
    //  단점 : 두 개의 0(+0, -0)이 존재한다. cpu에 빼기 연산을 별도로 설계해야 함
    // => 1000 0000 0000 0000 0000 0000 0001 0111
    // => 23 + (-23) = 0
    // => 정말?
    //    0000 0000 0000 0000 0000 0000 0001 0111
    //    1000 0000 0000 0000 0000 0000 0001 0111 +
    //    --------------------------------------- 2가 되면 0
    //    1000 0000 0000 0000 0000 0000 0010 1110 -(32+8+4+2)=-46
    //    이 방식은 23 + (-23) 의 결과가 옳게 나오지 않는다.

    // 2) 1's complement (1의 보수) 1이 되기 위해 보충하는 수
    //    모든 비트를 1이 되는 수로 바꾼다. 즉 0을 1로, 1을 0으로 바꾼다.
    //  단점 : 두 개의 0(+0, -0)이 존재한다. 두 수를 더한 후 ★비트 크기를 초과한★ 1 값을 다시 맨 뒤에 더해야 한다.
    // => 1111 1111 1111 1111 1111 1111 1110 1000 (-23)
    // 23 + (-23)
    //    0000 0000 0000 0000 0000 0000 0001 0111
    //    1111 1111 1111 1111 1111 1111 1110 1000 +
    //    --------------------------------------- 2가 되면 0
    //    1111 1111 1111 1111 1111 1111 1111 1111 = 0이 아니다.
    //    +                                     1 = (1을 추가로 더한다)   ->불편. 2의 보수 등장
    //    ---------------------------------------
    //   10000 0000 0000 0000 0000 0000 0000 0000 = 0
    //   음수를 더할 때는 항상 결과에 1을 추가해야 한다.


    // ★3) 2's complement
    // 자바에서 음수를 저장하는 방법
    // => 1의 보수로 저장된 음수 값을 더할 때마다 계산 결과에 1을 추가하는 번거로움을 없애기 위해
    // 음수를 저장할 때 1을 추가해두는 방법 (음수 0을 없앰으로써 -128까지 표현이 가능)
    // => 1의 보수 + 1 => 2의 보수
    // 23 + (-23)
    //    0000 0000 0000 0000 0000 0000 0001 0111
    //    1111 1111 1111 1111 1111 1111 1110 1001 +
    //    --------------------------------------- 2가 되면 0
    //   10000 0000 0000 0000 0000 0000 0000 0000 = 0
    //   그래서 컴퓨터에서 음수를 메모리에 저장할 때는
    //   양수와 음수를 더할 때 정상적인 값이 나오도록 2의 보수 방법으로 음수를 저장한다.
    //   ★2의 보수를 만드는 방법
    //   오른쪽에서부터 1을 찾는다. 찾은 1의 왼쪽편에 있는 모든 비트를 반대 값으로 바꾼다.
    //   예) 0010 1100(44) 1101 0100(-44)
  }
}